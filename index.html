<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Repeat (Beckett-ish Loop Prototype)</title>
  <style>
    :root { --bg:#0b0b0f; --fg:#e8e8ef; --mut:#a7a7b2; --line:#2a2a34; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background: radial-gradient(1200px 700px at 50% 35%, #151521 0%, var(--bg) 55%, #050507 100%);
      color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }

    .stage{
      width:min(960px, 92vw); border:1px solid var(--line); border-radius:16px;
      overflow:hidden; box-shadow: 0 30px 80px rgba(0,0,0,.45);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
    }

    .stageWrap{ position:relative; }

    header{
      padding:16px 18px; display:flex; gap:12px; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--line);
      position:relative; z-index:2;
      backdrop-filter: blur(2px);
    }
    .title{ font-weight:700; letter-spacing:.02em; }
    .meta{ color:var(--mut); font-size:12px; display:flex; gap:10px; align-items:center; }
    .tag{ border:1px solid var(--line); padding:4px 8px; border-radius:999px; }
    main{ padding:18px; display:grid; gap:14px; position:relative; z-index:2; }

    .scene{
      border:1px solid var(--line); border-radius:14px; padding:14px;
      background: rgba(0,0,0,.25);
      position:relative;
    }
    .scene::before{
      content:""; position:absolute; inset:0; border-radius:14px; pointer-events:none;
      background: radial-gradient(600px 240px at 50% 0%, rgba(255,255,255,.05), transparent 60%);
      mix-blend-mode: screen;
    }

    .log{
      height: 320px; overflow:auto; padding:10px;
      border:1px solid var(--line); border-radius:12px;
      background: rgba(0,0,0,.35);
    }
    .line{ margin:0 0 10px 0; line-height:1.6; }
    .who{ color:var(--mut); font-weight:600; margin-right:.4em; }
    .narr{ color:#cfcfe6; opacity:.9; font-style:italic; }
    .choices{ display:grid; gap:10px; }
    button{
      text-align:left; padding:12px 12px; border-radius:12px;
      border:1px solid var(--line); background: rgba(255,255,255,.03);
      color:var(--fg); cursor:pointer; transition: transform .06s ease, background .15s ease;
    }
    button:hover{ background: rgba(255,255,255,.06); }
    button:active{ transform: translateY(1px); }
    .footer{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      color:var(--mut); font-size:12px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .noise{
      position:absolute; inset:0; pointer-events:none; opacity:0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      mix-blend-mode: overlay;
      border-radius:14px;
    }
    .cycle-2 .noise{ opacity:.05; }
    .cycle-3 .noise{ opacity:.10; }
    .cycle-4 .noise{ opacity:.16; }

    /* ===== 立ち絵（口パク対応） ===== */
    .chara{
      position:absolute;
      bottom:10px;
      width:min(240px, 30vw);
      opacity:.88;
      filter: drop-shadow(0 22px 50px rgba(0,0,0,.55));
      pointer-events:none;
      transition: opacity .12s ease, transform .12s ease, filter .12s ease;
      z-index:1;
      user-select:none;
    }
    .chara.left{ left:14px; }
    .chara.right{ right:14px; transform: scaleX(-1); }

    .chara.is-speaking{
      opacity:1;
      filter: drop-shadow(0 26px 60px rgba(0,0,0,.65));
      transform: translateY(-2px);
    }
    .chara.right.is-speaking{
      transform: scaleX(-1) translateY(-2px);
    }
    .chara.is-dim{ opacity:.52; }

    @media (max-width: 680px){
      .chara{ width:min(170px, 36vw); opacity:.84; }
      header{ padding:14px 14px; }
      main{ padding:14px; }
    }
  </style>
</head>

<body>
  <div class="stage" id="app">
    <div class="stageWrap">
      <!-- 口パク用PNG：assets/ に置く -->
      <img class="chara left"  id="charaA" src="./assets/a_idle.png" alt="A">
      <img class="chara right" id="charaB" src="./assets/b_idle.png" alt="B">

      <header>
        <div class="title">Repeat</div>
        <div class="meta">
          <span class="tag">静的プロトタイプ</span>
          <span>cycle: <span class="mono" id="cycleView">1</span></span>
          <button id="resetBtn" title="進行を初期化" style="padding:6px 10px;border-radius:10px;">reset</button>
        </div>
      </header>

      <main>
        <section class="scene" id="scene">
          <div class="noise" aria-hidden="true"></div>
          <div class="log" id="log" aria-live="polite"></div>
        </section>

        <section class="choices" id="choices"></section>

        <div class="footer">
          <div>選択して進める。終わったように見えて戻る。</div>
          <div class="mono" id="nodeView"></div>
        </div>
      </main>
    </div>
  </div>

<script>
const $log = document.getElementById("log");
const $choices = document.getElementById("choices");
const $cycleView = document.getElementById("cycleView");
const $nodeView = document.getElementById("nodeView");
const $resetBtn = document.getElementById("resetBtn");

const charaA = document.getElementById("charaA");
const charaB = document.getElementById("charaB");

const STORAGE_KEY = "repeat_prototype_state_v1";

const SPRITES = {
  A: { idle: "./assets/a_idle.png", talk: "./assets/a_talk.png" },
  B: { idle: "./assets/b_idle.png", talk: "./assets/b_talk.png" },
};

function preload(url){
  return new Promise((resolve)=>{
    const img = new Image();
    img.onload = ()=>resolve(true);
    img.onerror = ()=>resolve(false);
    img.src = url;
  });
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return { nodeId:"start", cycle:1, history:[] };
    const s = JSON.parse(raw);
    if(!s || typeof s.nodeId !== "string") throw new Error("bad state");
    return { nodeId: s.nodeId, cycle: Number(s.cycle)||1, history: Array.isArray(s.history)? s.history : [] };
  } catch {
    return { nodeId:"start", cycle:1, history:[] };
  }
}
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
let state = loadState();

/* ===== 口パク制御 ===== */
let talkTimerA = null;
let talkTimerB = null;

function safeHideIfMissing(imgEl){
  if(!imgEl) return;
  imgEl.addEventListener("error", ()=>{ imgEl.style.display = "none"; });
}
safeHideIfMissing(charaA);
safeHideIfMissing(charaB);

function setSpeakingFocus(who){
  if(!charaA || !charaB) return;

  charaA.classList.remove("is-speaking","is-dim");
  charaB.classList.remove("is-speaking","is-dim");

  if(who === "A"){
    charaA.classList.add("is-speaking");
    charaB.classList.add("is-dim");
  } else if(who === "B"){
    charaB.classList.add("is-speaking");
    charaA.classList.add("is-dim");
  } else {
    charaA.classList.add("is-dim");
    charaB.classList.add("is-dim");
  }
}

function mouthFlap(who, text){
  // ナレーションは口パクしない
  if(who !== "A" && who !== "B") return;

  const img = who === "A" ? charaA : charaB;
  const sp = SPRITES[who];
  if(!img || img.style.display === "none") return;

  // テキスト長に応じて時間を決める（やりすぎない）
  const len = String(text || "").length;
  const duration = Math.min(900, Math.max(260, len * 55)); // 260ms〜900ms

  // 既存タイマーをクリア
  if(who === "A" && talkTimerA) clearTimeout(talkTimerA);
  if(who === "B" && talkTimerB) clearTimeout(talkTimerB);

  // 口開きにする
  img.src = sp.talk;

  // ちょいちょい口をパクパク（talk/idle切替）
  // CSSアニメではなくタイマーで簡易制御（静的でOK）
  const start = performance.now();
  const flap = ()=>{
    const t = performance.now() - start;
    if(t >= duration){
      img.src = sp.idle;
      return;
    }
    img.src = (img.src.includes("_talk") ? sp.idle : sp.talk);
    setTimeout(flap, 120);
  };
  setTimeout(flap, 120);

  // 最後に必ず idle に戻す保険
  const endTimer = setTimeout(()=>{ img.src = sp.idle; }, duration + 160);

  if(who === "A") talkTimerA = endTimer;
  if(who === "B") talkTimerB = endTimer;
}

/* ===== 微差演出 ===== */
function degrade(text, cycle){
  if(cycle <= 1) return text;
  let t = text;
  if(cycle === 2 && t.length > 8) t = t.slice(0, t.length - 1) + "…";
  if(cycle >= 3){
    t = t.replace(/[、。]/g, (m)=> (Math.random()<0.35 ? "" : m));
    if(Math.random()<0.18 && t.length>10) t = t.replace(/です|だ|する/g, "…");
  }
  return t;
}
function variant(text, cycle){
  if(cycle <= 1) return text;
  const swaps = [
    ["今日", "今"], ["少し", "わずかに"], ["待つ", "待っている"], ["来る", "来ない"], ["大丈夫", "たぶん"]
  ];
  let t = text;
  if(cycle === 2){
    const [a,b] = swaps[(cycle + text.length) % swaps.length];
    t = t.replace(a, b);
  } else if(cycle >= 3){
    const [a,b] = swaps[Math.floor(Math.random()*swaps.length)];
    t = t.includes(a) ? t.replace(a, b) : t.replace(b, a);
  }
  return t;
}

const nodes = {
  start: {
    lines: (cycle)=>[
      { who:"A", text: variant("今日も待つ。", cycle) },
      { who:"B", text: variant("誰を？", cycle) },
      { who:"A", text: variant("来るはずの、誰かを。", cycle) },
      { who:"",  text: "沈黙。", narr:true }
    ],
    choices: (cycle)=>[
      { label: degrade("「場所が違うのでは？」", cycle), to:"place" },
      { label: degrade("「もう帰ろう」", cycle), to:"leave" },
      { label: degrade("「待とう」", cycle), to:"wait" },
    ]
  },
  place: {
    lines: (cycle)=>[
      { who:"B", text: variant("場所が違うのかもしれない。", cycle) },
      { who:"A", text: variant("昨日も同じことを言った。", cycle) },
      { who:"B", text: variant("昨日？", cycle) },
      { who:"",  text: "風。", narr:true }
    ],
    choices: (cycle)=>[
      { label: degrade("周囲を見回す", cycle), to:"look" },
      { label: degrade("やはり待つ", cycle), to:"wait" },
      { label: degrade("帰ろう（と言う）", cycle), to:"leave" },
    ]
  },
  look: {
    lines: (cycle)=>[
      { who:"",  text: variant("木が一本。道が一本。空。", cycle), narr:true },
      { who:"A", text: variant("目印はある。", cycle) },
      { who:"B", text: variant("目印は、目印のふりをしている。", cycle) }
    ],
    choices: (cycle)=>[
      { label: degrade("目印を信じる", cycle), to:"wait" },
      { label: degrade("目印を疑う", cycle), to:"wait" },
      { label: degrade("何もしない", cycle), to:"wait" },
    ]
  },
  leave: {
    lines: (cycle)=>[
      { who:"A", text: variant("帰ろう。", cycle) },
      { who:"B", text: variant("帰る場所があるのか？", cycle) },
      { who:"A", text: variant("あるはずだ。", cycle) },
      { who:"",  text: "二人は動かない。", narr:true }
    ],
    choices: (cycle)=>[
      { label: degrade("立ち上がる（が、動かない）", cycle), to:"wait" },
      { label: degrade("座り直す", cycle), to:"wait" },
      { label: degrade("黙る", cycle), to:"wait" },
    ]
  },
  wait: {
    lines: (cycle)=>[
      { who:"",  text: variant("待つ時間が、時間を待っている。", cycle), narr:true },
      { who:"B", text: variant("来る？", cycle) },
      { who:"A", text: variant("来ると言われた。", cycle) },
      { who:"B", text: variant("誰に？", cycle) },
      { who:"A", text: variant("…忘れた。", cycle) }
    ],
    choices: (cycle)=>[
      { label: degrade("「明日また来よう」", cycle), to:"curtain" },
      { label: degrade("「今夜はここで」", cycle), to:"curtain" },
      { label: degrade("「終わりにしよう」", cycle), to:"curtain" },
    ]
  },
  curtain: {
    lines: (cycle)=>[
      { who:"", text:"幕が下りる。", narr:true },
      { who:"", text: variant("だが、下りきらない。", cycle), narr:true },
    ],
    choices: (cycle)=>[
      { label: degrade("（次の幕へ）", cycle), to:"__loop__" },
    ]
  }
};

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  })[c]);
}

function appendLine(line){
  const p = document.createElement("p");
  p.className = "line";

  const text = line.narr ? line.text : line.text;
  if(line.narr){
    p.innerHTML = `<span class="narr">${escapeHtml(text)}</span>`;
  } else {
    p.innerHTML = `<span class="who">${escapeHtml(line.who)}</span>${escapeHtml(text)}`;
  }

  $log.appendChild(p);
  $log.scrollTop = $log.scrollHeight;

  const who = line.narr ? "" : line.who;
  setSpeakingFocus(who);
  mouthFlap(who, text);
}

function render(){
  $cycleView.textContent = String(state.cycle);
  $nodeView.textContent = `node: ${state.nodeId}`;

  const app = document.getElementById("app");
  app.classList.toggle("cycle-2", state.cycle===2);
  app.classList.toggle("cycle-3", state.cycle===3);
  app.classList.toggle("cycle-4", state.cycle>=4);

  const node = nodes[state.nodeId];
  if(!node) return;

  $log.innerHTML = "";
  const lines = node.lines(state.cycle).map(l=>({
    ...l,
    text: degrade(l.text, state.cycle)
  }));
  lines.forEach(appendLine);

  $choices.innerHTML = "";
  node.choices(state.cycle).forEach(ch=>{
    const btn = document.createElement("button");
    btn.textContent = ch.label;
    btn.addEventListener("click", ()=>go(ch.to, ch.label));
    $choices.appendChild(btn);
  });
}

function go(to, label){
  state.history.push({ cycle: state.cycle, from: state.nodeId, pick: label });

  if(to === "__loop__"){
    state.cycle = Math.min(state.cycle + 1, 99);
    state.nodeId = "start";
  } else {
    state.nodeId = to;
  }

  saveState();
  render();
}

$resetBtn.addEventListener("click", ()=>{
  state = { nodeId:"start", cycle:1, history:[] };
  saveState();
  render();
});

// 画像プリロード（無い場合でも落ちない）
(async ()=>{
  await Promise.all([
    preload(SPRITES.A.idle), preload(SPRITES.A.talk),
    preload(SPRITES.B.idle), preload(SPRITES.B.talk),
  ]);
  // 初期画像を確実にidleに
  if(charaA && charaA.style.display !== "none") charaA.src = SPRITES.A.idle;
  if(charaB && charaB.style.display !== "none") charaB.src = SPRITES.B.idle;
  render();
})();

/* DEBUG */
window.__repeat = {
  get state(){ return state; },
  setNode(id){ state.nodeId = id; saveState(); render(); },
  setCycle(n){ state.cycle = n; saveState(); render(); },
  clear(){
    localStorage.removeItem(STORAGE_KEY);
    state = { nodeId:"start", cycle:1, history:[] };
    render();
  }
};
</script>
</body>
</html>
